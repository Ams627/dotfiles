np() {
 (/c/program\ files/notepad++/notepad++.exe $* &)
}

squash () {
    regexnum='^[0-9]+$'
    if ! [[ $1 =~ $regexnum ]]; then
        echo "error: Please specify a number of commits to squash" 1>&2
        return 1
    fi
    if [[ $1 -eq 0 ]]; then
        echo "error: cannot squash zero commits" 1>&2
        return 1
    fi
    if [[ $1 -eq 1 ]]; then
        echo "error: cannot squash a single commit" 1>&2
        return 1
    fi
    messageCommit=$(($1-1))
    message=$(git show -s --format=%s HEAD~$messageCommit)
    echo using commmit message: $message
    git reset --soft HEAD~$1 && git commit -m "$message"
}

subjects() {
    git log --pretty=format:"%h %an %s" --max-count=$1
}

# go to the root dir of a git repo
root() {
    curr=$PWD
    while :
    do
        if [[ -d ".git" ]]; then
            break
        fi
        if [[ -f ".git" ]]; then
            break
        fi
        if [[ $PWD = / ]]; then
            break
        fi
        cd ..
    done
    
    if [[ $PWD = / ]]; then
        cd $curr
    fi
    sln
}

ccd() {
    regexnum='^[0-9]+$'
    if [[ $1 =~ $regexnum ]]; then
        cwd=$PWD
        root
        if [[ -f ".ccd/last" ]]; then
            count=0
            while IFS=$'\n\r' read -r line; do
                if [[ count == $1 ]]; then
                    cd $line
                    echo > ~/.ccd/bashmonitor/bashes/$$
                    return 0
                fi
                ((count++))
            done < ".ccd/last"
        else 
            echo "Please run ccd i or ccd -i first"
            return -1
        fi
    fi
    r=$(cchangedirectory $*)
    read -r firstline <<< $r
    if [[ firstline =~ '^#!cd ([.+])' ]] ; then
        echo > ~/.ccd/bashmonitor/bashes/$$
        cd ${BASH_REMATCH[1]}
        return 0
    fi
    echo "$r"
}


read2() {
while IFS=$'\n\r' read -r line; do 
echo $line
done < $1
}


psl() {
ps | while read -r line; do 
    read -ra arr <<< "$line"
    echo ${arr[1]} ${arr[3]}
done
}

sln() {
    orig=$PWD
    while ! compgen -G *.sln >/dev/null 2>&1
    do
        if [[ "$PWD" == "/" ]] ; then 
            cd $orig
            break;
        fi
        cd ..
    done
}

dnp() {
    cwd=$PWD
    echo $cwd
    root
    dotnet publish --nologo
    echo $cwd
    cd $cwd
}

dn() {
    orig=$PWD
    root
    dotnet build --nologo
    cd $orig
}

dbg() {
    sln
    filename=$(compgen -G *.sln)
    filename="${filename%.*}"
    cd $filename/bin/Debug
}

pub() {
    sln
    filename=$(compgen -G *.sln)
    filename="${filename%.*}"
    cd $filename/bin/win-x64/publish
}

gup() {
    git add -u && git commit -mupdates && git push
}

down() {
    cd ~/downloads
}

sa() {
    asubst a
}

sb() {
    asubst b
}


sx() {
    asubst x
}

sy() {
    asubst y
}

sz() {
    asubst z
}





ta() {
    cd $(asubst -t a)
}

tb() {
    cd $(asubst -t b)
}

tx() {
    cd $(asubst -t x)
}

ty() {
    cd $(asubst -t y)
}

tz() {
    cd $(asubst -t z)
}

dx() {
    cd ~/downloads && asubst x && cd -
}

dy() {
    cd ~/downloads && asubst y && cd -
}

dz() {
    cd ~/downloads && asubst z && cd -
}


aa() {
    if [[ ${1::2} == "-r" ]] || [[ ${1::2} == "-m" ]] || [[ ${1::2} == "-l" ]] || [[ ${1::2} == "-t" ]];
    then
        ada $*
        unalias -a
        . ~/.dir-aliases
        . ~/.aliases
    elif [[ $(type -t $1) ]]; then
        echo already an alias, function or command;
    else
        ada -a $1
        unalias -a
        . ~/.dir-aliases
        . ~/.aliases
    fi
}

nkill() {
    pskill notepad++
}


pww() {
    wdir=$(pwd -W)
    echo -n ${wdir////\\} >/dev/clipboard
}

gcurr() {
    git branch --show-current
}


mc() {
    mkdir $1 && cd $1
}

mcx() {
    mkdir $1
    cd $1
    sx
}

mcy() {
    mkdir $1
    cd $1
    sy
}

mcz() {
    mkdir $1
    cd $1
    sz
}